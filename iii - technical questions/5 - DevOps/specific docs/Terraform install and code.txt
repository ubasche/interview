
Terraform install and code
==========================

https://blog.gruntwork.io/an-introduction-to-terraform-f17df9c6d180

--------------------------------------------------
 ###  Misc
--------------------------------------------------

Important AWS Policies:

    AmazonEC2FullAccess:      required for this blog post.
    AmazonS3FullAccess:       required for How to manage Terraform state.
    AmazonDynamoDBFullAccess: required for How to manage Terraform state.
    AmazonRDSFullAccess:      required for How to create reusable infrastructure with Terraform modules.
    CloudWatchFullAccess:     required for Terraform tips & tricks: loops, if-statements, and pitfalls.
    IAMFullAccess:            required for Terraform tips & tricks: loops, if-statements, and pitfalls.


--------------------------------------------------
 ###  Install / setup Terraform
--------------------------------------------------    

1. Download the Terraform executable

2. Configure your AWS credentials

    export AWS_ACCESS_KEY_ID=(your access key id)
    export AWS_SECRET_ACCESS_KEY=(your secret access key)
    
3. Create a HCL file with .tf extention

    vi main.tf
    
    Define the provider

      provider "aws" {
        region = "us-east-2"
      }
      
    Define the resource, e.g. an EC2 instance

       resource "<PROVIDER>_<TYPE>" "<NAME>" {
         [CONFIG …]
       }
    
      resource "aws_instance" "example" {
        ami           = "ami-0c55b159cbfafe1f0"
        instance_type = "t2.micro"
        
        tags = {
          Name = "terraform-example"                     <== Name of the EC2 instance
        }        
      }
      
4. Initialize

    $ terraform init            
    
    --> The provider code will be downloaded into a .terraform folder
    
5. Create a plan

    $ terraform plan
    
    The plan command lets you see what Terraform will do before actually doing it. 
    
6. Apply the plan

    $ terraform apply
    
    output
    ...
    -/+ resource ...       # replace the resource
    + resource ...         # add the resource
    - resource ...         # remove the resource
    ...
    

--------------------------------------------------
 ###  Deploy a single web server
--------------------------------------------------

ws.sh
>>>>>
#!/bin/bash
echo "Hello, World" > index.html
nohup busybox httpd -f -p 8080 &
<<<<<

This is a bash script that writes the text “Hello, World” into index.html a
nd runs a web server on port 8080 using busybox (which is installed by default on Ubuntu) 
serve that file at the URL “/”.


-- We’re going to run the script above as part of the EC2 Instance’s User Data, 
   which AWS will execute when the instance is booting.

main.tf
>>>>>
resource "aws_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  
  user_data = <<-EOF
              #!/bin/bash
              echo "Hello, World" > index.html
              nohup busybox httpd -f -p 8080 &
              EOF  
              
  tags = {
    Name = "terraform-example"
  }
}
<<<<<


-- To allow the EC2 Instance to receive traffic on port 8080, you need to create a security group:

.....
resource "aws_security_group" "instance" {
  name = "terraform-example-instance"  ingress {
    from_port   = 8080
    to_port     = 8080
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
.....


Simply creating a security group isn’t enough; you also need to tell the 
EC2 Instance to actually use it by passing the ID of the security group
into the vpc_security_group_ids argument of the aws_instance resource. 

Expressions:

  An expression in Terraform is anything that returns a value.
  
  One particularly useful type of expression is a reference, which allows you to access values 
  from other parts of your code. To access the ID of the security group resource, you are 
  going to need to use a resource attribute reference, which uses the following syntax:

    <PROVIDER>_<TYPE>.<NAME>.<ATTRIBUTE>

  The security group exports an attribute called id, so the expression to reference 
  it will look like this:

    aws_security_group.instance.id
    

You can use this security group ID in the vpc_security_group_ids parameter of the aws_instance:

main.tf
>>>>
resource "aws_instance" "example" {
  ami                    = "ami-0c55b159cbfafe1f0"
  instance_type          = "t2.micro"
  vpc_security_group_ids = [aws_security_group.instance.id]  
  
  user_data = <<-EOF
              #!/bin/bash
              echo "Hello, World" > index.html
              nohup busybox httpd -f -p 8080 &
              EOF  
              
  tags = {
    Name = "terraform-example"
  }
}
<<<<<


When you add a reference from one resource to another, you create an implicit dependency.
Terraform parses these dependencies, builds a dependency graph from them, and uses that
to automatically figure out in what order it should create resources. 


-- Test the web server

  $ curl http://<EC2_INSTANCE_PUBLIC_IP>:8080
  Hello, World


--------------------------------------------------
 ###  Deploy a Configurable Web Server
--------------------------------------------------

The Don’t Repeat Yourself (DRY) principle.
 
To allow you to make your code more DRY and more configurable, 
Terraform allows you to define input variables. 
The syntax for declaring a variable is:

  variable "NAME" {
    [CONFIG ...]
  }


  variable "server_port" {
    description = "The port the server will use for HTTP requests"
    type        = number
    default     = 8080
  }


  -- Let terraform ask for the variable value
  
    $ terraform apply
   
      var.server_port
        The port the server will use for HTTP requests  
      
        Enter a value:
  
  -- Pass the parameter value on the command line
    
    $ terraform apply -var "server_port=8080"

  -- Set an environment variable for the parameter value
  
    $ export TF_VAR_server_port=8080
    $ terraform apply


  Reference the variable in the code:
  
    .....
    resource "aws_security_group" "instance" {
      name = "terraform-example-instance"  
      
      ingress {
        from_port   = var.server_port
        to_port     = var.server_port
        protocol    = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
      }
    }
    .....
    
  To use a reference inside of a string literal, you need to use a new type of expression 
  called an interpolation, which has the following syntax:

    "${...}"
    
    .....
    user_data = <<-EOF
              #!/bin/bash
              echo "Hello, World" > index.html
              nohup busybox httpd -f -p "${var.server_port}" &
              EOF
    .....
    
              
Output variables


  In addition to input variables, Terraform also allows you to define output variables 
  with the following syntax:

    output "<NAME>" {
      value = <VALUE>
      [CONFIG ...]
    }

  NAME is the name of the output variable
  VALUE can be any Terraform expression that you would like to output. 
  CONFIG can contain two additional parameters, both optional:

    description: To document what type of data is contained in the output variable.
    sensitive: Set this parameter to "true" to tell Terraform not to log this output 
               at the end of terraform apply. This is useful if the output variable 
               contains sensitive material or secrets, such as passwords or private keys.
    


  For example, instead of having to manually poke around the EC2 console 
  to find the IP address of your server, you can provide the IP address 
  as an output variable:

    .....
    output "public_ip" {
      value       = aws_instance.example.public_ip
      description = "The public IP of the web server"
    }
    .....
    
    
  Execute it:
  
  $ terraform apply
  
    .....
    aws_security_group.instance: Refreshing state... 
    aws_instance.example: Refreshing state...
    
    Apply complete! Resources: 0 added, 0 changed, 0 destroyed.
    
    Outputs:
    
    public_ip = 54.174.13.5
    .....

  -- List outputs without applying changes
  
    $ terraform output
    public_ip = 54.174.13.5
  
    $ terraform output public_ip
    54.174.13.5


--------------------------------------------------
 ###  Deploy a cluster of web servers
--------------------------------------------------

Using an Auto Scaling Group (ASG) you can automatically launch a cluster of EC2 Instances, 
monitor their health, automatically restart failed nodes, and adjust the size of 
the cluster in response to demand.

-- reate a launch configuration, which specifies how to configure each EC2 Instance in the ASG.

.....
resource "aws_launch_configuration" "example" {
  image_id        = "ami-0c55b159cbfafe1f0"
  instance_type   = "t2.micro"
  security_groups = [aws_security_group.instance.id]  
  
  user_data = <<-EOF
              #!/bin/bash
              echo "Hello, World" > index.html
              nohup busybox httpd -f -p "${var.server_port}" &
              EOF  
              
  lifecycle {
    create_before_destroy = true
  }
}
.....


Now you can create the ASG itself using the aws_autoscaling_group resource:

.....
resource "aws_autoscaling_group" "example" {
  launch_configuration = aws_launch_configuration.example.id  
  availability_zones   = data.aws_availability_zones.all.names
  
  min_size = 2
  max_size = 10  

  load_balancers    = [aws_elb.example.name]
  health_check_type = "ELB"
    
  tag {
    key                 = "Name"
    value               = "terraform-asg-example"
    propagate_at_launch = true
  }
}
.....


Deploy a load balancer

In order to have only one ip address you need a load balanceer.

AWS offers three different types of load balancers:

    1. Application Load Balancer (ALB):  Best suited for HTTP and HTTPS traffic.
    2. Network Load Balancer (NLB):  Best suited for TCP and UDP traffic.
    3. Classic Load Balancer (CLB): 
        This is the “legacy” load balancer that predates both the ALB and NLB.
        It can do HTTP, HTTPS, and TCP, but offers far fewer features than the ALB or NLB.
    
    You can create a CLB using the aws_elb resource:

.....
resource "aws_elb" "example" {
  name               = "terraform-asg-example"
  security_groups    = [aws_security_group.elb.id]
  availability_zones = data.aws_availability_zones.all.names  

  health_check {
    target              = "HTTP:${var.server_port}/"
    interval            = 30
    timeout             = 3
    healthy_threshold   = 2
    unhealthy_threshold = 2
  }
  
  # This adds a listener for incoming HTTP requests.      
  listener {
    lb_port           = 80
    lb_protocol       = "http"
    instance_port     = var.server_port
    instance_protocol = "http"
  }
}
.....

In the code above, we are telling the CLB to receive HTTP requests on port 80 (the default port for HTTP) and to route them to the port used by the Instances in the ASG. Note that, by default, CLBs don’t allow any incoming or outgoing traffic (just like EC2 Instances), so you need to add a new security group to explicitly allow inbound requests on port 80 and all outbound requests (the latter is to allow the CLB to perform health checks, as you’ll see shortly)


.....
resource "aws_security_group" "elb" {
  name = "terraform-example-elb"  
  
  # Allow all outbound
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }  
  
  # Inbound HTTP from anywhere
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
.....

One last thing to do before deploying the load balancer: let’s add its DNS name 
as an output so it’s easier to test if things are working:

output "clb_dns_name" {
  value       = aws_elb.example.dns_name
  description = "The domain name of the load balancer"
}



<<< EOF >>>
